# asyncio

### 1. Introduction to coroutine

Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, 
by allowing execution to be suspended and resumed.This means that unlike Threads which can be preempted 
from OS, coroutines are not prempted from outside but give control themselves. This avoids any requirment 
of synchronisation primitives such as lock or critical section

### 2. The big picture

<div><img src="../../../../../images/diagram.png"></div><br>
Consider an event loop with 2 queue, ready and waiting. We create a new task/coroutine to perform an IO 
operation or configure remote device and put it in ready queue. Initially execution control is with event
loop which it passes to the new task in ready queue. Task starts execution. Whenever task need to wait 
from results, it can move to waiting queue and give control back to event loop. Event loop then gives the
control to next task in ready queue. Meanwhile when task get the result, it is moved from waiting to ready
queue. 

### 3. Async and await syntax

#### simple way

```python
import asyncio

async def main():          # refer your function as a coroutine
    print('Hello ...')
    await asyncio.sleep(1) # mark your statement which can go for IO bound work
    print('... World!')

# Python 3.7+
asyncio.run(main())        # this gets the event loop and runs the coroutine
```
asyncio.run function runs the passed coroutine, taking care of managing the asyncio event loop.

#### another way

```python
async def main():
    loop = asyncio.get_event_loop()
    
    task1 = asyncio.create_task(
        say_after(1, 'hello'))

    task2 = asyncio.create_task(
        say_after(2, 'world'))

    print(f"started at {time.strftime('%X')}")
    ctask = asyncio.gather(task1, task2)
    loop.run_until_complete(ctask)
    print(f"finished at {time.strftime('%X')}")
```
